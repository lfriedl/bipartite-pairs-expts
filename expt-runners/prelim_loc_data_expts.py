from __future__ import print_function
from builtins import str, map, range
from scipy import sparse
import numpy as np
import random
import score_data
import sys
import gzip

sys.path.append("../expt-code")
from loc_data import read_loc_adj_mat  # note: would move this fn here, except that it's needed by the other repo's tests
import experiment_runner

# Reads existing data sets (generated by read_sample_save) to send to expts
def get_loc_expt_data(adj_mat_infile, edges_infile, row_ids_infile):
    """

    :param adj_mat_infile: bipartite graph. Each line = 1 item (name), followed by pipe-separated affils.
    :param edges_infile: true pairs. Each line = 2 item names (tab-separated).
    :param row_ids_infile: this expt will use subgraph induced by this set of items. N.B. stored as indices, not names.
    :return:
    """
    adj_mat, row_labels, _ = read_loc_adj_mat(adj_mat_infile)

    with open(row_ids_infile, 'r') as fin:
        row_ids_to_keep = sorted(map(int, fin.readline().split()))  # row ids are all on one line, space-separated

    adj_mat_to_keep = adj_mat[row_ids_to_keep,]
    row_labels_to_keep = [row_labels[i] for i in row_ids_to_keep]
    label_generator = get_label_generator_from_edgefile(edges_infile, row_labels_to_keep)

    return adj_mat_to_keep, row_labels_to_keep, label_generator


# Use for generating data sets. Read the full adj_mat, choose rows to keep,
# save just the row IDs. Also return a function that creates edge labels (for these specific rows).
# Returns: adj_mat, row labels for that matrix, function that generates true labels
def read_sample_save(adj_mat_infile, edges_infile, num_nodes, rows_outfile):
    adj_mat, item_names, _ = read_loc_adj_mat(adj_mat_infile)

    row_ids_to_keep = set(random.sample(list(range(adj_mat.shape[0])), num_nodes)) # indices w/in adj_mat
    adj_mat_to_keep = adj_mat[sorted(row_ids_to_keep),]
    item_names_to_keep = [item_names[i] for i in sorted(row_ids_to_keep)]  # oddly, subset notation above doesn't work

    # challenge: adj_mat_to_keep doesn't remember the old/semantically meaningful row labels. Need to keep these around
    # to send to the pair generators.

    print("Sampled " + str(num_nodes) + " nodes")
    with open(rows_outfile, 'wt') as fp:
        fp.write(" ".join(map(str, sorted(row_ids_to_keep))))   # probably need better syntax

    # edges can be stored efficiently in another sparse matrix
    label_generator = get_label_generator_from_edgefile(edges_infile, item_names_to_keep)

    return adj_mat_to_keep, item_names_to_keep, label_generator


# Utility function for reading the true pairs data.
# Returns adj_mat of true edges, plus row_labels_map mapping item name to index in this adj_mat.
# ids_to_keep: if present, tells us which item names to keep. We ignore all other nodes.
def load_edge_matrix(edges_infile, labels_to_keep=None):
    coord_row = []
    coord_col = []
    row_labels = []         # position --> label
    row_labels_map = {}     # label --> position
    if labels_to_keep is not None:
        row_labels = labels_to_keep
        row_labels_map = {labels_to_keep[pos]:pos for pos in range(len(labels_to_keep))} # map of name --> index

    with open_poss_compressed(edges_infile) as fpin:
        for line in fpin:
            item1, item2 = list(map(int, line.split()))

            if labels_to_keep is None or (item1 in labels_to_keep and item2 in labels_to_keep):
                item1_num = row_labels_map.get(item1, len(row_labels_map))
                if item1_num == len(row_labels_map):
                    # we just gave it a new one!
                    row_labels_map[item1] = item1_num
                    row_labels.append(item1_num)
                item2_num = row_labels_map.get(item2, len(row_labels_map))
                if item2_num == len(row_labels_map):
                    # we just gave it a new one!
                    row_labels_map[item2] = item2_num
                    row_labels.append(item2_num)

                coord_row.append(item1_num)
                coord_col.append(item2_num)

    num_people = len(row_labels_map)
    edge_matrix = sparse.csc_matrix(([1] * len(coord_row), (coord_row, coord_col)), dtype=np.int8,
                                    shape=(num_people, num_people))
    return edge_matrix, row_labels_map


# Returns a label generator -- i.e., something that can be passed to score_pairs and handles an arbitrary set of pairs.
def get_label_generator_from_edgefile(edges_infile, node_labels_to_keep):
    # Note: edge file starts numbering people with 0, like bipartite_adj file.
    edge_matrix, edge_row_labels_map = load_edge_matrix(edges_infile, node_labels_to_keep)
    num_edges = edge_matrix.count_nonzero() / 2
    print("Found " + str(num_edges) + " edges for the rows")
    if num_edges == 0:
        return None

    def get_true_labels_given_my_edges(pairs_generator):
        return get_true_labels_loc_data(pairs_generator, edge_matrix, edge_row_labels_map)
    return get_true_labels_given_my_edges

# Given a pairs_generator and the true pairs data, returns an array of (values 0 or 1) edge labels.
def get_true_labels_loc_data(pairs_generator, edge_matrix, edge_row_labels_map):
    labels = []
    for (row_idx1, row_idx2, item1_name, item2_name, pair_x, pair_y) in pairs_generator:
        label = True if (edge_matrix[edge_row_labels_map[item1_name], edge_row_labels_map[item2_name]] == 1) else False
        labels.append(label)
    return labels

# (relevant only if we include people w/diff degrees in the same data set)
def check_degree_corr(adj_mat_infile, edges_infile):
    """
    Print and return correlation between vector of people's affil degrees and vector of people's num friends degrees
    :param adj_mat_infile:
    :param edges_infile:
    :return:
    """
    adj_mat, row_labels, _ = read_loc_adj_mat(adj_mat_infile)
    edge_matrix, _ = load_edge_matrix(edges_infile)
    pass # not finished, not needed now




def run_expts_loc_data(loc_data_name='brightkite', existing_data=False, inference_subdir='inference'):
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round3.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round2.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round2_filter.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round1.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round1_filter.txt'
    # adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round0_filter.txt'
    # edges_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/loc-' + loc_data_name + '_edges.txt'
    adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/brightkite/bipartite_adj_10friends.txt'
    edges_infile = '/Users/lfriedl/Documents/dissertation/real-data/brightkite/loc-edges_10friends.txt'

    exptdir = '/Users/lfriedl/Documents/dissertation/binary-ndim/' + loc_data_name + '-expts'
    for i in range(70, 79):
        rowIDs_file = exptdir + '/data' + str(i) + '.rowIDs'
        evals_outfile = exptdir + '/' + inference_subdir + '/results' + str(i) + '.txt'
        scored_pairs_outfile= exptdir + '/' + inference_subdir + '/scoredPairs' + str(i) + ".csv.gz"
        if existing_data:
            adj_mat, row_labels, label_generator = get_loc_expt_data(adj_mat_infile, edges_infile, rowIDs_file)
        else:
            adj_mat, row_labels, label_generator = read_sample_save(adj_mat_infile, edges_infile, num_nodes=500, rows_outfile=rowIDs_file)

        if label_generator is None:
            print("Found no edges; stopping")

        else:
            score_data.run_and_eval(adj_mat, true_labels_func = label_generator, method_spec="all",
                                    evals_outfile = evals_outfile,
                                    pair_scores_outfile=scored_pairs_outfile, row_labels=row_labels,
                                    print_timing=True, prefer_faiss=True) #, expt1=True)

# Utility fn for possibly compressed file
open_poss_compressed = lambda f: gzip.open(f,"r") if f.endswith(".gz") else open(f)

if __name__ == "__main__":

    #run_expts_loc_data()
    #run_expts_loc_data(loc_data_name = 'gowalla')
    #run_expts_loc_data(existing_data=True, inference_subdir='inference_round3')
    # run_expts_loc_data(existing_data=True, inference_subdir='inference_round0_filter')

    # run_expts_loc_data(inference_subdir='inference_10friends')
    # experiment_runner.score_whole_directory(
    #     data_dir='/Users/lfriedl/Documents/dissertation/binary-ndim/gowalla-expts/stratified_9friends',
    #     num_trials=20, inference_dir_name="inf_test",
    #     run_in_parallel=True,
    #     remove_boundary_items=False, remove_boundary_affils=True,
    #     loc_data_bipartite_file='/Users/lfriedl/Documents/dissertation/real-data/gowalla/stratified/bipartite_adj_9friends.txt',
    #     loc_data_true_pairs_file='/Users/lfriedl/Documents/dissertation/real-data/gowalla/stratified/loc-edges_9friends.txt',
    #     # sims_for_mixed_pairs=[.2],
    #     # method_spec=methods,
    #     # save_pair_scores=False,
    #     prefer_faiss=True, verbose=False)

    experiment_runner.score_whole_directory(
        data_dir='/Users/lfriedl/Documents/dissertation/binary-ndim/brightkite-expts/stratified_9friends',
        num_trials=20, inference_dir_name="inf_test",
        run_in_parallel=True,
        remove_boundary_items=False, remove_boundary_affils=True,
        loc_data_bipartite_file='/Users/lfriedl/Documents/dissertation/real-data/brightkite/stratified2/bipartite_adj_9friends.txt',
        loc_data_true_pairs_file='/Users/lfriedl/Documents/dissertation/real-data/brightkite/stratified2/loc-edges_9friends.txt',
        # sims_for_mixed_pairs=[.2],
        # method_spec=methods,
        # save_pair_scores=False,
        prefer_faiss=True, verbose=False)