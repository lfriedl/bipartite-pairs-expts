from __future__ import print_function
from builtins import str, map, range
from scipy import sparse
import numpy as np
import random
import score_data
import sys

sys.path.append("../expt-code")
from loc_data import read_loc_adj_mat  # note: this would belong here, except that it's needed by the other repo's tests


# Reads existing data sets (generated by read_sample_save) to send to expts
def get_loc_expt_data(adj_mat_infile, edges_infile, row_ids_infile):
    """

    :param adj_mat_infile: bipartite graph. Each line = 1 item (name), followed by pipe-separated affils.
    :param edges_infile: true pairs. Each line = 2 item names (tab-separated).
    :param row_ids_infile: this expt will use subgraph induced by this set of items. N.B. stored as indices, not names.
    :return:
    """
    adj_mat, row_labels, _ = read_loc_adj_mat(adj_mat_infile)

    with open(row_ids_infile, 'r') as fin:
        row_ids_to_keep = sorted(map(int, fin.readline().split()))  # row ids are all on one line, space-separated

    adj_mat_to_keep = adj_mat[row_ids_to_keep,]
    row_labels_to_keep = [row_labels[i] for i in row_ids_to_keep]
    label_generator = get_label_generator_from_edgefile(edges_infile, row_labels_to_keep)

    return adj_mat_to_keep, row_labels_to_keep, label_generator


# Use for generating data sets. Read the full adj_mat, choose rows to keep,
# save just the row IDs. Also return a function that creates edge labels (for these specific rows).
# Returns: adj_mat, row labels for that matrix, function that generates true labels
def read_sample_save(adj_mat_infile, edges_infile, num_nodes, rows_outfile):
    adj_mat, row_labels, _ = read_loc_adj_mat(adj_mat_infile)

    row_ids_to_keep = set(random.sample(list(range(adj_mat.shape[0])), num_nodes))
    adj_mat_to_keep = adj_mat[sorted(row_ids_to_keep),]
    row_labels_to_keep = [row_labels[i] for i in sorted(row_ids_to_keep)]  # oddly, subset notation above doesn't work

    # challenge: adj_mat_to_keep doesn't remember the old/semantically meaningful row labels. Need to keep these around
    # to send to the pair generators.

    print("Sampled " + str(num_nodes) + " nodes")
    with open(rows_outfile, 'wt') as fp:
        fp.write(" ".join(map(str, sorted(row_ids_to_keep))))   # probably need better syntax

    # edges can be stored efficiently in another sparse matrix
    label_generator = get_label_generator_from_edgefile(edges_infile, row_labels_to_keep)

    return adj_mat_to_keep, row_labels_to_keep, label_generator


# Utility function for reading the true pairs data.
# Returns adj_mat of true edges, plus row_labels_map mapping item name to index in the adj_mat.
# ids_to_keep: if present, tells us which item names to keep. We ignore all other nodes.
def load_edge_matrix(edges_infile, ids_to_keep=None):
    coord_row = []
    coord_col = []
    row_labels = []         # position --> label
    row_labels_map = {}     # label --> position
    if ids_to_keep is not None:
        row_labels = ids_to_keep
        row_labels_map = {ids_to_keep[pos]:pos for pos in range(len(ids_to_keep))} # map of name --> index

    with open(edges_infile, 'r') as fpin:
        for line in fpin:
            item1, item2 = list(map(int, line.split()))

            if ids_to_keep is None or (item1 in ids_to_keep and item2 in ids_to_keep):
                item1_num = row_labels_map.get(item1, len(row_labels_map))
                if item1_num == len(row_labels_map):
                    # we just gave it a new one!
                    row_labels_map[item1] = item1_num
                    row_labels.append(item1_num)
                item2_num = row_labels_map.get(item2, len(row_labels_map))
                if item2_num == len(row_labels_map):
                    # we just gave it a new one!
                    row_labels_map[item2] = item2_num
                    row_labels.append(item2_num)

                coord_row.append(item1_num)
                coord_col.append(item2_num)

    num_people = len(row_labels_map)
    edge_matrix = sparse.csc_matrix(([1] * len(coord_row), (coord_row, coord_col)), dtype=np.int8,
                                    shape=(num_people, num_people))
    return edge_matrix, row_labels_map


# Returns a label generator -- i.e., something that can be passed to score_pairs and handles an arbitrary set of pairs.
def get_label_generator_from_edgefile(edges_infile, ids_to_keep):
    # Note: edge file starts numbering people with 0, like bipartite_adj file.
    edge_matrix, edge_row_labels_map = load_edge_matrix(edges_infile, ids_to_keep)
    num_edges = edge_matrix.count_nonzero()
    print("Found " + str(num_edges) + " edges for the rows")
    if num_edges == 0:
        return None

    def get_true_labels_given_my_edges(pairs_generator):
        return get_true_labels_loc_data(pairs_generator, edge_matrix, edge_row_labels_map)
    return get_true_labels_given_my_edges

# Given a pairs_generator and the true pairs data, returns an array of (values 0 or 1) edge labels.
def get_true_labels_loc_data(pairs_generator, edge_matrix, edge_row_labels_map):
    labels = []
    for (row_idx1, row_idx2, item1_name, item2_name, pair_x, pair_y) in pairs_generator:
        label = True if (edge_matrix[edge_row_labels_map[item1_name], edge_row_labels_map[item2_name]] == 1) else False
        labels.append(label)
    return labels


def run_expts_loc_data(loc_data_name='brightkite', existing_data=False, inference_subdir='inference'):
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round3.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round2.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round2_filter.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round1.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round1_filter.txt'
    # adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round0_filter.txt'
    # edges_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/loc-' + loc_data_name + '_edges.txt'
    adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/brightkite/bipartite_adj_10friends.txt'
    edges_infile = '/Users/lfriedl/Documents/dissertation/real-data/brightkite/loc-edges_10friends.txt'

    exptdir = '/Users/lfriedl/Documents/dissertation/binary-ndim/' + loc_data_name + '-expts'
    for i in range(70, 79):
        rowIDs_file = exptdir + '/data' + str(i) + '.rowIDs'
        evals_outfile = exptdir + '/' + inference_subdir + '/results' + str(i) + '.txt'
        scored_pairs_outfile= exptdir + '/' + inference_subdir + '/scoredPairs' + str(i) + ".csv.gz"
        if existing_data:
            adj_mat, row_labels, label_generator = get_loc_expt_data(adj_mat_infile, edges_infile, rowIDs_file)
        else:
            adj_mat, row_labels, label_generator = read_sample_save(adj_mat_infile, edges_infile, num_nodes=500, rows_outfile=rowIDs_file)

        if label_generator is None:
            print("Found no edges; stopping")

        else:
            score_data.run_and_eval(adj_mat, true_labels_func = label_generator, method_spec="all",
                                    evals_outfile = evals_outfile,
                                    pair_scores_outfile=scored_pairs_outfile, row_labels=row_labels,
                                    print_timing=True, prefer_faiss=True) #, expt1=True)

if __name__ == "__main__":

    #run_expts_loc_data()
    #run_expts_loc_data(loc_data_name = 'gowalla')
    #run_expts_loc_data(existing_data=True, inference_subdir='inference_round3')
    # run_expts_loc_data(existing_data=True, inference_subdir='inference_round0_filter')

    run_expts_loc_data(inference_subdir='inference_10friends')