from __future__ import print_function
from builtins import str, map, range
from scipy import sparse
import numpy as np
import random
import sys
import gzip

import affil_subsets
sys.path.append("../python-scoring")
import score_data
sys.path.append("../expt-code")
from loc_data import read_loc_adj_mat  # note: would move this fn here, except that it's needed by the other repo's tests
# import experiment_runner

# Reads existing data sets (generated by read_sample_save) to send to expts
def get_loc_expt_data(adj_mat_infile, edges_infile, row_ids_infile):
    """

    :param adj_mat_infile: bipartite graph. Each line = 1 item (name), followed by pipe-separated affils.
    :param edges_infile: true pairs. Each line = 2 item names (tab-separated).
    :param row_ids_infile: this expt will use subgraph induced by this set of items. N.B. stored as indices, not names.
    :return:
    """
    adj_mat, row_labels, _ = read_loc_adj_mat(adj_mat_infile)

    with open(row_ids_infile, 'r') as fin:
        row_ids_to_keep = sorted(map(int, fin.readline().split()))  # row ids are all on one line, space-separated

    adj_mat_to_keep = adj_mat[row_ids_to_keep,]
    row_labels_to_keep = [row_labels[i] for i in row_ids_to_keep]
    label_generator = get_label_generator_from_edgefile(edges_infile, row_labels_to_keep)

    return adj_mat_to_keep, row_labels_to_keep, label_generator


# Use for generating data sets. Read the full adj_mat, choose rows to keep,
# save just the row IDs. Also return a function that creates edge labels (for these specific rows).
# Returns: adj_mat, row labels for that matrix, function that generates true labels
def read_sample_save(adj_mat_infile, edges_infile, num_nodes, rows_outfile):
    adj_mat, item_names, _ = read_loc_adj_mat(adj_mat_infile)

    row_ids_to_keep = set(random.sample(list(range(adj_mat.shape[0])), num_nodes)) # indices w/in adj_mat
    adj_mat_to_keep = adj_mat[sorted(row_ids_to_keep),]
    item_names_to_keep = [item_names[i] for i in sorted(row_ids_to_keep)]  # oddly, subset notation above doesn't work

    # challenge: adj_mat_to_keep doesn't remember the old/semantically meaningful row labels. Need to keep these around
    # to send to the pair generators.

    print("Sampled " + str(num_nodes) + " nodes")
    with open(rows_outfile, 'wt') as fp:
        fp.write(" ".join(map(str, sorted(row_ids_to_keep))))   # probably need better syntax

    # edges can be stored efficiently in another sparse matrix
    label_generator = get_label_generator_from_edgefile(edges_infile, item_names_to_keep)

    return adj_mat_to_keep, item_names_to_keep, label_generator


# Utility function for reading the true pairs data.
# Returns adj_mat of true edges, plus row_labels_map mapping item name to index in this adj_mat.
# ids_to_keep: if present, tells us which item names to keep. We ignore all other nodes.
def load_edge_matrix(edges_infile, labels_to_keep=None):
    coord_row = []
    coord_col = []
    row_labels = []         # position --> label
    row_labels_map = {}     # label --> position
    if labels_to_keep is not None:
        row_labels = labels_to_keep
        row_labels_map = {labels_to_keep[pos]:pos for pos in range(len(labels_to_keep))} # map of name --> index

    with open_poss_compressed(edges_infile) as fpin:
        for line in fpin:
            item1, item2 = list(map(int, line.split()))[:2]     # the [:2] takes the first 2 fields even if there are more

            if labels_to_keep is None or (item1 in labels_to_keep and item2 in labels_to_keep):
                item1_num = row_labels_map.get(item1, len(row_labels_map))
                if item1_num == len(row_labels_map):
                    # we just gave it a new one!
                    row_labels_map[item1] = item1_num
                    row_labels.append(item1_num)
                item2_num = row_labels_map.get(item2, len(row_labels_map))
                if item2_num == len(row_labels_map):
                    # we just gave it a new one!
                    row_labels_map[item2] = item2_num
                    row_labels.append(item2_num)

                coord_row.append(item1_num)
                coord_col.append(item2_num)

    num_people = len(row_labels_map)
    edge_matrix = sparse.csc_matrix(([1] * len(coord_row), (coord_row, coord_col)), dtype=np.int8,
                                    shape=(num_people, num_people))
    return edge_matrix, row_labels_map


# Returns a label generator -- i.e., something that can be passed to score_pairs and handles an arbitrary set of pairs.
def get_label_generator_from_edgefile(edges_infile, node_labels_to_keep):
    # Note: edge file starts numbering people with 0, like bipartite_adj file.
    edge_matrix, edge_row_labels_map = load_edge_matrix(edges_infile, node_labels_to_keep)
    num_edges = edge_matrix.count_nonzero() / 2
    print("Found " + str(num_edges) + " edges for the rows")
    if num_edges == 0:
        return None

    def get_true_labels_given_my_edges(pairs_generator):
        return get_true_labels_loc_data(pairs_generator, edge_matrix, edge_row_labels_map)
    return get_true_labels_given_my_edges

# Given a pairs_generator and the true pairs data, returns an array of (values 0 or 1) edge labels.
def get_true_labels_loc_data(pairs_generator, edge_matrix, edge_row_labels_map):
    labels = []
    for (row_idx1, row_idx2, item1_name, item2_name, pair_x, pair_y) in pairs_generator:
        label = True if (edge_matrix[edge_row_labels_map[item1_name], edge_row_labels_map[item2_name]] == 1) else False
        labels.append(label)
    return labels

# (relevant only if we include people w/diff degrees in the same data set)
def check_degree_corr(adj_mat_infile, edges_infile):
    """
    Print and return correlation between vector of people's affil degrees and vector of people's num friends degrees
    :param adj_mat_infile:
    :param edges_infile:
    :return:
    """
    adj_mat, row_labels, _ = read_loc_adj_mat(adj_mat_infile)
    edge_matrix, _ = load_edge_matrix(edges_infile)
    pass # not finished, not needed now


def run_all_pairs_loc_data(adj_mat_infile, edges_infile, outdir, tag):
    # modified just a bit from get_loc_expt_data()
    adj_mat, row_names, affil_names = read_loc_adj_mat(adj_mat_infile)
    label_generator = get_label_generator_from_edgefile(edges_infile, row_names)

    evals_outfile = outdir + '/results_' + tag + '.txt'
    scored_pairs_outfile = outdir + '/scoredPairs_' + tag + '.csv.gz'
    all_methods_to_run = ['jaccard', 'cosine', 'cosineIDF', 'shared_size', 'hamming', 'pearson',
                          'shared_weight11', 'shared_weight1100', 'adamic_adar', 'newman', 'weighted_corr',
                          'mixed_pairs']
    # (for gowalla, just ran standard before)
    mixed_pairs_sims = [.001, .005, .01, .05, .1, .2, .3, .4, .5]

    score_data.run_and_eval(adj_mat, true_labels_func=label_generator, method_spec=all_methods_to_run,  #[method],
                            evals_outfile=evals_outfile, mixed_pairs_sims=mixed_pairs_sims,
                            pair_scores_outfile=scored_pairs_outfile, row_labels=row_names,
                            remove_boundary_items=False,
                            print_timing=True, prefer_faiss=True)



def affil_subsets_loc_data(adj_mat_infile, edges_infile, outdir, tag, affil_subset_fraction, affil_subset_type):
    adj_mat, row_names, affil_names = read_loc_adj_mat(adj_mat_infile)
    label_generator = get_label_generator_from_edgefile(edges_infile, row_names)

    tmp_pi_vector = np.asarray(adj_mat.sum(axis=0)).squeeze() / float(adj_mat.shape[0])
    affils_to_keep = affil_subsets.compute_affil_subsets(tmp_pi_vector, affil_subset_fraction, affil_subset_type)
    adj_mat = adj_mat[:, affils_to_keep]

    evals_outfile = outdir + '/results_' + tag + '.txt'
    scored_pairs_outfile = outdir + '/scoredPairs_' + tag + '.csv.gz'
    all_methods_to_run = ['jaccard', 'cosine', 'cosineIDF', 'shared_size', 'hamming', 'pearson',
                          'shared_weight11', 'shared_weight1100', 'adamic_adar', 'newman', 'weighted_corr',
                          'mixed_pairs']

    score_data.run_and_eval(adj_mat, true_labels_func=label_generator, method_spec=all_methods_to_run,  #[method],
                            evals_outfile=evals_outfile,
                            pair_scores_outfile=scored_pairs_outfile, row_labels=row_names,
                            remove_boundary_items=False,
                            print_timing=True, prefer_faiss=True)


def loc_compute_corrs():
    adj_mat_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/bipartite_adj_6friends.txt.gz'
    edges_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/loc-edges_6friends.txt.gz'
    # or original files (on local machine)
    adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/gowalla/bipartite_adj.txt'
    edges_infile = '/Users/lfriedl/Documents/dissertation/real-data/gowalla/loc-gowalla_edges.txt'

    adj_mat, row_names, affil_names = read_loc_adj_mat(adj_mat_infile)
    edge_matrix, edge_row_labels_map = load_edge_matrix(edges_infile, row_names)
    friends_per_item = adj_mat.sum(axis=1)
    affils_per_item = edge_matrix.sum(axis=1)

    correlation = np.corrcoef(friends_per_item, affils_per_item, rowvar=False)[0, 1]
    #print("correlation: " + str(correlation) + " for gowalla 6friends")
    print("correlation: " + str(correlation) + " for gowalla original")


def run_expts_loc_data(loc_data_name='brightkite', existing_data=False, inference_subdir='inference'):
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round3.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round2.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round2_filter.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round1.txt'
    #adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round1_filter.txt'
    # adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/bipartite_adj_round0_filter.txt'
    # edges_infile = '/Users/lfriedl/Documents/dissertation/real-data/' + loc_data_name + '/loc-' + loc_data_name + '_edges.txt'
    adj_mat_infile = '/Users/lfriedl/Documents/dissertation/real-data/brightkite/bipartite_adj_10friends.txt'
    edges_infile = '/Users/lfriedl/Documents/dissertation/real-data/brightkite/loc-edges_10friends.txt'

    exptdir = '/Users/lfriedl/Documents/dissertation/binary-ndim/' + loc_data_name + '-expts'
    for i in range(70, 79):
        rowIDs_file = exptdir + '/data' + str(i) + '.rowIDs'
        evals_outfile = exptdir + '/' + inference_subdir + '/results' + str(i) + '.txt'
        scored_pairs_outfile= exptdir + '/' + inference_subdir + '/scoredPairs' + str(i) + ".csv.gz"
        if existing_data:
            adj_mat, row_labels, label_generator = get_loc_expt_data(adj_mat_infile, edges_infile, rowIDs_file)
        else:
            adj_mat, row_labels, label_generator = read_sample_save(adj_mat_infile, edges_infile, num_nodes=500, rows_outfile=rowIDs_file)

        if label_generator is None:
            print("Found no edges; stopping")

        else:
            score_data.run_and_eval(adj_mat, true_labels_func = label_generator, method_spec="all",
                                    evals_outfile = evals_outfile,
                                    pair_scores_outfile=scored_pairs_outfile, row_labels=row_labels,
                                    print_timing=True, prefer_faiss=True) #, expt1=True)

# Utility fn for possibly compressed file
open_poss_compressed = lambda f: gzip.open(f,"r") if f.endswith(".gz") else open(f)

def record_of_runs():
    run_all_pairs_loc_data(
        adj_mat_infile='/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/bipartite_adj_6friends.txt.gz',
        edges_infile='/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/loc-edges_6friends.txt.gz',
        outdir='/home/lfriedl/ASOUND-bipartite/expts/loc_data/gowalla/allpairs_6friends', tag="all")

    for value in range(1,10):
        tag = "affils_max." + str(value)
        fraction = value / 10.
        affil_subsets_loc_data(adj_mat_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/bipartite_adj_6friends.txt.gz',
                           edges_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/loc-edges_6friends.txt.gz',
                           outdir = '/home/lfriedl/ASOUND-bipartite/expts/loc_data/gowalla/allpairs_6friends',
                           tag=tag, affil_subset_fraction=fraction, affil_subset_type=2)

    run_all_pairs_loc_data(
        adj_mat_infile='/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/brightkite/stratified/bipartite_adj_6friends.txt.gz',
        edges_infile='/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/brightkite/stratified/loc-edges_6friends.txt.gz',
        outdir='/home/lfriedl/ASOUND-bipartite/expts/loc_data/brightkite/allpairs_6friends', tag="all")
    affil_subsets_loc_data(adj_mat_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/brightkite/stratified/bipartite_adj_6friends.txt.gz',
                       edges_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/brightkite/stratified/loc-edges_6friends.txt.gz',
                       outdir = '/home/lfriedl/ASOUND-bipartite/expts/loc_data/brightkite/allpairs_6friends',
                       tag="affils_rand0.25", affil_subset_fraction=0.25, affil_subset_type=1)
    affil_subsets_loc_data(adj_mat_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/brightkite/stratified/bipartite_adj_6friends.txt.gz',
                       edges_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/brightkite/stratified/loc-edges_6friends.txt.gz',
                       outdir = '/home/lfriedl/ASOUND-bipartite/expts/loc_data/brightkite/allpairs_6friends',
                       tag="affils_max0.25", affil_subset_fraction=0.25, affil_subset_type=2)
    affil_subsets_loc_data(adj_mat_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/brightkite/stratified/bipartite_adj_6friends.txt.gz',
                       edges_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/brightkite/stratified/loc-edges_6friends.txt.gz',
                       outdir = '/home/lfriedl/ASOUND-bipartite/expts/loc_data/brightkite/allpairs_6friends',
                       tag="affils_min0.25", affil_subset_fraction=0.25, affil_subset_type=3)


if __name__ == "__main__":
    affil_subsets_loc_data(adj_mat_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/bipartite_adj_6friends.txt.gz',
                       edges_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/loc-edges_6friends.txt.gz',
                       outdir = '/home/lfriedl/ASOUND-bipartite/expts/loc_data/gowalla/allpairs_6friends',
                       tag="affils_rand0.25", affil_subset_fraction=0.25, affil_subset_type=1)
    affil_subsets_loc_data(adj_mat_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/bipartite_adj_6friends.txt.gz',
                       edges_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/loc-edges_6friends.txt.gz',
                       outdir = '/home/lfriedl/ASOUND-bipartite/expts/loc_data/gowalla/allpairs_6friends',
                       tag="affils_max0.25", affil_subset_fraction=0.25, affil_subset_type=2)
    affil_subsets_loc_data(adj_mat_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/bipartite_adj_6friends.txt.gz',
                       edges_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/loc-edges_6friends.txt.gz',
                       outdir = '/home/lfriedl/ASOUND-bipartite/expts/loc_data/gowalla/allpairs_6friends',
                       tag="affils_min0.25", affil_subset_fraction=0.25, affil_subset_type=3)
    exit(0)

    methods_to_run = ['jaccard', 'cosine', 'cosineIDF', 'shared_size', 'hamming', 'pearson',
                           'shared_weight11', 'shared_weight1100', 'adamic_adar', 'newman', 'weighted_corr',
                      'mixed_pairs']
    methods_to_run = ['shared_size']     # for testing
    for meth in methods_to_run:
        meth = "all"  # to get the right filename
        run_all_pairs_loc_data(adj_mat_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/bipartite_adj_6friends.txt.gz',
                               edges_infile = '/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/loc-edges_6friends.txt.gz',
                               outdir = '/home/lfriedl/ASOUND-bipartite/expts/loc_data/gowalla/allpairs_6friends', method=meth)
    #run_expts_loc_data()
    #run_expts_loc_data(loc_data_name = 'gowalla')
    #run_expts_loc_data(existing_data=True, inference_subdir='inference_round3')
    # run_expts_loc_data(existing_data=True, inference_subdir='inference_round0_filter')

    # run_expts_loc_data(inference_subdir='inference_10friends')
    # for i in range(6,10):
    #     experiment_runner.score_whole_directory(
    #          data_dir='/home/lfriedl/ASOUND-bipartite/expts/loc_data/gowalla/stratified_' + str(i) + 'friends',
    #          inference_dir_name="inf1",
    #          #num_trials=2,
    #          run_in_parallel=True,
    #          remove_boundary_items=False, remove_boundary_affils=True,
    #          loc_data_bipartite_file='/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/bipartite_adj_' + str(i) + 'friends.txt.gz',
    #          loc_data_true_pairs_file='/home/lfriedl/ASOUND-bipartite/data-prep/loc_data/interim/gowalla/stratified/loc-edges_' + str(i) + 'friends.txt.gz',
    #          # sims_for_mixed_pairs=[.2],
    #          # method_spec=methods,
    #          save_pair_scores=False, prefer_faiss=True, verbose=False)

    #experiment_runner.score_whole_directory(
    #    data_dir='/Users/lfriedl/Documents/dissertation/binary-ndim/brightkite-expts/stratified_9friends',
    #    num_trials=20, inference_dir_name="inf_test",
    #    run_in_parallel=True,
    #    remove_boundary_items=False, remove_boundary_affils=True,
    #    loc_data_bipartite_file='/Users/lfriedl/Documents/dissertation/real-data/brightkite/stratified2/bipartite_adj_9friends.txt',
    #    loc_data_true_pairs_file='/Users/lfriedl/Documents/dissertation/real-data/brightkite/stratified2/loc-edges_9friends.txt',
    #    # sims_for_mixed_pairs=[.2],
    #    # method_spec=methods,
    #    # save_pair_scores=False,
    #    prefer_faiss=True, verbose=False)
